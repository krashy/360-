复习：
   沙箱模式->
     就是写一个自执行函数，把我们要做的事放在这个自执行函数里面就好了。如果想在自执行函数外面获取里面的变量，那么就return 一个函数出来，利用闭包的特点完成。
     var f = (function (){
        要做的事情。
        var num;
        return function (){
            return num;
        }
     })()

1. 函数的调用模式：
    -> 为什么学习函数调用模式：  其实就是为了搞清楚函数里面的 this 指向问题。
    -> 函数定义的时候和this有什么关系：  没关系。函数定义在哪，怎么定义，和函数内部的 this 没关系。
    -> this 指向问题：  函数内部的this 指向，只和函数调用有关系（要看怎么调用）。

  -> 函数模式调用：   函数名()，理论上来说，函数名前面什么也不能有(因为前面可以写window)。
                   这个时候函数里面的 this 指向 window
  -> 方法模式调用：   对象.函数名()，函数一定是挂在某一个对象上的方法，调用的时候一定是由一个对象引导。
                   这个时候函数里面的 this 指向 引导的对象
  -> 构造模式调用：   new 是一个运算符，也就仅仅是个运算符而已。在函数名前面有new运算符的就是构造模式。
                   这个时候函数里面的 this 指向new出来的这个实例。
           /*
            * 构造函数的特点：
            *    new Foo; 创建实例的时候，如果没有传参可以省略括号。
            *    如果我想让Foo这个构造函数的实例直接调用原型上面的方法
            *    可以写成 new Foo().getName();
            *           他的含义就是 使用Foo这个构造函数的实例去调用getName方法。
            *           他不可以写成 new Foo.getName();
            *           他的函数是把Foo当成一个对象来看待，new的是Foo这个对象上的getName方法
            *    也可以写成 (new Foo).getName();
           *           他的含义就是 使用Foo这个构造函数的实例去调用getName方法。
            *    当出现两个以上的new 的时候：除了离函数名最近的哪个new以外，剩下的都是new一个整体
            *           new new new Foo().getName();
            *           他真正的意思就是new (new (new Foo().getName();))
            * */

  -> 上下文模式调用： 真正的核心其实就是在改变函数中的 this 指向问题。
        语法：
        函数名.apply( ... );
          看到这样一个东西出现，要有一些下意识的反应：
            -> 他是上下文模式调用的函数。（不用刻到骨头里）
            -> 下面的是要刻到骨头里
            -> 这个函数中定义的 this 已经被改变过了（不管函数名前面有没有“.”，都已经不重要了）
            -> apply只有由函数调用。（只能写成 函数名.apply();）
            -> 这样调用以后，函数依旧会被执行。
            -> 这个时候后面的那个括号里面，必须至少有一个参数。（只有一种情况可以不写）
            -> 括号里面的第一个参数就是该函数中 this 的指向。
          到这里 call 和 apply 都是完全一样的，唯一的区别就是从第二个参数开始。
        函数名.apply(null,[])
            -> 第一个参数：就是前面函数中的this指向。
            -> 第二个参数：是一个数组，数组中从第 0 项开始一次是给函数传递的实参。
            -> 如果给函数传递参数的话，那么括号中的第一个参数必须写。
            -> apply这个语法只对当前语句中的函数执行有作用，并不会影响后面的函数执行
        函数名.call( ... );
            -> 所有的表现形式、使用方法都和apply一模一样。
            -> 唯一不一样的一点就是传参的形式。
                apply第二个参数是一个数组的形式，数组中从第 0 项开始一次是给函数传递的参数
                call没有什么限制，就是从第二个参数开始，依次是给函数传递的参数。
                fn.call( null , 1, "a", {},function(){}, [])
                从第二个参数开始，全部都是fn函数调用的参数
                fn(1, "a", {},function(){}, []);

补充知识点：（脸熟，认识）
2. bind();
   var 变量名 = 函数名.bind( 对象 );
     与call 和 apply 的区别：
     -> 调用bind方法括号里面只有一个参数，这个参数就是一个对象。
        就好像把这个函数挂在了这个对象上（对象.函数名 = 函数名）
     -> bind方法在调用的时候，当前语句中的函数并不执行。
     -> bind方法有返回值，他返回的就是前面那个个函数，只不过这个返回的函数在调用的时候，就相当于（对象.函数名）调用。
     -> 如果向让函数执行的话，必须用一个变量名接收返回值，写变量名调用。（变量名();）
     与call 和 apply 的相同：
     -> 都可以改变this指向：把前面函数中的this指向改变成了后面括号内的那个对象
     -> 都是需要用函数做引导调用。
     -> 都不会影响原先的函数，在他后面的语句，函数该怎么使用还怎么使用。

3. Object.prototype中的一些成员
    1) constructor
   	2) hasOwnProperty 判断该属性是否为自己提供（就是判断这个属性是否是这个对象自己本身的）
   	3) propertyIsEnumerable 判断属性是否可以枚举（隐身）
   	4) isPrototypeOf 判断是否为原型对象（用来验证是否是原型）
   	5) toString, toLocaleString, valueOf

4. 语法糖：
    var o = (function () {
    	var num = 123;
    	return {
    		get num () {
    			return num;
    		},
    		set num ( v ) {
    			num = v;
    		}
    	};
    })();
    是为了获取闭包中的私有数据。
    我们要书写成 o.get_num()  --> 就是在获取数据
    但是有人看着他不舒服， 就是想把 o.get_num() 写成 o.num
    让后面那种书写格式也可以是获取数据
    把之间闭包中return出来的哪个函数 改造一下
    get_num: function () {
        return num;
    }
    改造成
    get num () {
        return num;
    }
    别的全都不用改变。
    仅仅只是这样书写以后，就可以了。
    就可以使用 o.num 来获取数据了。

    -> 读写器就是一种格式，不要试图去研究原理。
    -> 就是记住书写格式，就可以了。

5. 数组
    var arr = [1,2,3,4];
    -> $.each(function (index,item){});
    -> forEach(function (item,index){});
       遍历循环数组，参数中那个函数里面的 item 就是数组中每一项的值；index就是数组的索引。
       他没有返回值。
    -> map(function (item,index){
            return item * item;
       });
       遍历循环数组，只不过它有一个返回值，他的返回值是把我们数组中的每一项一一替换掉。
       他不会破坏原数组，map是返回一个新数组，返回的新数组，就是通过里面函数中的算法计算好的数组。



    3 filter 就是筛选
         语法:     数组.filter( function ( v, i ) { return 条件 })
         var arr = [ 1, 2, 3, 4, 5, 6 ];
         var a = arr.filter( function ( v ) { return v % 2 === 1; });
         filter 是有返回值的，他是把原先数组中所有符合我们设定的条件的值，全部打包放在一个新数组中返回。


    4 some 判断数组中至少有一个数据复合要求 就返回 true, 否则返回 false
         var arr = [ '123', {}, function () {}, '123' ];
         判断数组中至少有一个数数字
         var isTrue = arr.some( function ( v ) { return typeof v === 'number'; } );
         some 也是有返回值的，返回的是一个布尔值。当原数组中至少有一个是符合我们设定的条件的，那么就返回true。
         some 就是原数组中有 1 到 多个 符合我们设定的条件的值。

    5 every 必须满足所有元素都复合要求才会返回 true
         var arr = [ 1, 2, 3, 4, 5, '6' ];
         var isTrue = arr.every( function ( v ) { return typeof v === 'number'; } );
         every 也是有返回值的，返回值是一个布尔值。当原数组中的每一项都符合我们设定的条件的时候，才会返回true。
         只要有一个不符合，那么就返回false


    6 indexOf 在数组中查找元素, 如果含有该元素, 返回元素的需要( 索引 ), 否则返回 -1
         var arr = [ 1, 2, 3, 4, 5 ];
         var res = arr.indexOf( 4 );
         console.log( res );
         indexOf也是有返回值的。查找原数组中有没有我们传递的参数的这一项，如果有，就返回对应的索引，如果没有，就都返回 -1
         indexOf中的第二个参数，是设置查找的初始位置。不写默认是0。（这个初始位置就是数组的索引，也就是从那一项开始查找）
         var arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];
         var res = arr.indexOf( 4, 4 );
         console.log( res );

    7 lastIndexOf 从右往左找
         var arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];
         var res = arr.lastIndexOf( 4 );
         console.log( res );
         lastIndexOf 和 indexOf一模一样，只不过是倒过来找（也就是从右至左的找），数组的索引不倒过来，还是原先的顺序。









